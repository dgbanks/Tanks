{"version":3,"sources":["webpack:///webpack/bootstrap e01d9e80cc8d7274ec52","webpack:///./lib/bullet.js","webpack:///./lib/tanks.js","webpack:///./lib/game.js","webpack:///./lib/barrier.js","webpack:///./lib/tank.js","webpack:///./lib/game_view.js","webpack:///(webpack)/buildin/global.js","webpack:///./lib/explosion.js","webpack:///./lib/player_one.js","webpack:///./lib/enemy_tank.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACrEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,0CAA0C;AACnE;AACA,CAAC;;;;;;;ACTD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AClJA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACvBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;;AAEA;;;;;;;AC7HA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,wBAAwB;;AAEpE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;AC3BA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e01d9e80cc8d7274ec52","class Bullet {\n  constructor(posObject) {\n    this.pos = posObject.tankPos;\n    this.mousePos = posObject.mousePos;\n    this.speed = 5;\n    this.slope = this.calcSlope();\n    this.radius = 5;\n    this.color = 'white';\n  }\n\n  calcSlope() {\n    let slope = [(this.mousePos[0] - this.pos[0]),\n                (this.mousePos[1] - this.pos[1])];\n\n    if (Math.abs(slope[0]) >= Math.abs(slope[1])) {\n      slope = [(slope[0] / Math.abs(slope[0])),\n              (slope[1] / Math.abs(slope[0]))];\n    } else {\n      slope = [(slope[0] / Math.abs(slope[1])),\n              (slope[1] / Math.abs(slope[1]))];\n    }\n\n    return slope;\n  }\n\n  move() {\n    let slope = this.slope;\n\n    slope = [(slope[0] * this.speed), (slope[1] * this.speed)];\n    this.pos = [(this.pos[0] + slope[0]), (this.pos[1] + slope[1])];\n  }\n\n  // willCollide(objects) {\n  //   // let property;\n  //   // if (object instanceof Tank) {\n  //   //   property = object.width / 2;\n  //   // } else {\n  //   //   property = object.radius;\n  //   // }\n  //\n  //   objects.forEach(object => {\n  //\n  //   });\n  //\n  //   let bool;\n  //   this.barriers.forEach(barrier => {\n  //     if ((\n  //       (object.pos[0] + property) >= barrier.sides.left &&\n  //       (object.pos[0] - property) <= barrier.sides.right\n  //     ) && (\n  //       (object.pos[1] + property) >= barrier.sides.top &&\n  //       (object.pos[1] - property) <= barrier.sides.bottom\n  //     )) {\n  //       bool = true;\n  //     }\n  //   });\n  //\n  //   return bool;\n  // }\n\n  draw(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], this.radius, 0, (2 * Math.PI), false);\n    ctx.fill();\n  }\n\n}\n\nmodule.exports = Bullet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/bullet.js\n// module id = 0\n// module chunks = 0","const Game = require('./game.js');\nconst GameView = require('./game_view');\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n  const canvas = document.getElementById('game-map');\n  const context = canvas.getContext('2d');\n\n  const game = new Game({dimensions: [canvas.width, canvas.height]});\n  new GameView(game, context, canvas).start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tanks.js\n// module id = 1\n// module chunks = 0","const Tank = require('./tank');\nconst PlayerOne = require('./player_one');\nconst EnemyTank = require('./enemy_tank');\nconst Barrier = require('./barrier');\nconst Bullet = require('./bullet');\nconst Explosion = require('./explosion');\n\nclass Game {\n  constructor(canvas) {\n    this.dimensions = canvas.dimensions;\n    this.tanks = [];\n    this.bullets = [];\n    this.barriers = [];\n    this.explosions = [];\n  }\n\n  addTank() {\n    const tank = new PlayerOne(this);\n    this.tanks.push(tank);\n    this.playerOne = tank;\n    return tank;\n  }\n\n  addEnemies() {\n    const tank = new EnemyTank(this);\n    this.tanks.push(tank);\n    this.enemy = tank;\n    return tank;\n  }\n\n  addBullet(bullet) {\n    this.bullets.push(bullet);\n    return bullet;\n  }\n\n  addBarriers() {\n    const boundaries = [\n      new Barrier(0, 0, 800, 10),\n      new Barrier(0, 590, 800, 10),\n      new Barrier(0, 10, 10, 580),\n      new Barrier(790, 10, 10, 580)\n    ];\n\n    const startingCover = [\n      new Barrier(100, 250, 20, 100),\n      new Barrier(680, 250, 20, 100)\n    ];\n\n    const levelOne = [\n      new Barrier(390, 100, 20, 150),\n      new Barrier(390, 350, 20, 150)\n    ];\n\n    this.barriers = [].concat(boundaries, startingCover, levelOne);\n    return this.barriers;\n  }\n\n\n  getMovingObjects() {\n    return [].concat(this.tanks, this.bullets);\n  }\n\n  willCollide(object) {\n    let property;\n    if (object instanceof Tank) {\n      property = object.width / 2;\n    } else {\n      property = object.radius;\n    }\n\n    let bool;\n    this.barriers.forEach(barrier => {\n      if ((\n        (object.pos[0] + property) >= barrier.sides.left &&\n        (object.pos[0] - property) <= barrier.sides.right\n      ) && (\n        (object.pos[1] + property) >= barrier.sides.top &&\n        (object.pos[1] - property) <= barrier.sides.bottom\n      )) {\n        bool = true;\n      }\n    });\n\n    return bool;\n  }\n\n  moveObjects(direction) {\n    this.getMovingObjects().forEach(object => {\n        if (object instanceof Tank) {\n            if (!object.canMove(direction)) {\n              direction = [0, 0];\n            }\n            object.move(direction);\n            object.moveDirection = [0, 0];\n        } else {\n            object.move();\n            if (this.willCollide(object)) {\n              const explosion = new Explosion(object.pos);\n              this.explosions.push(explosion);\n              setTimeout(() => {\n                this.explosions = this.explosions.filter(ex => (\n                  ex !== explosion\n                ));\n              }, 300);\n\n              this.bullets = this.bullets.filter(bullet => (\n                bullet !== object\n              ));\n            }\n        }\n    });\n  }\n\n  drawEverything(ctx, mouseObject) {\n    // render the canvas\n    ctx.clearRect(0, 0, this.dimensions[0], this.dimensions[1]);\n    ctx.fillStyle = 'black';\n    ctx.fillRect(0, 0, this.dimensions[0], this.dimensions[1]);\n\n    // render barriers and boundaries\n    this.barriers.forEach(barrier => {\n      barrier.draw(ctx);\n    });\n\n    // render moving objects\n    this.getMovingObjects().forEach(object => {\n      object.draw(ctx);\n    });\n\n    this.explosions.forEach(explosion => {\n      explosion.draw(ctx);\n    });\n\n    // render the player's aim\n    ctx.beginPath();\n    ctx.moveTo(this.playerOne.pos[0], this.playerOne.pos[1]);\n    ctx.lineTo(mouseObject.mousePos[0], mouseObject.mousePos[1]);\n    ctx.strokeStyle = 'white';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    this.playerOne.swivelCannon(mouseObject.mousePos);\n    this.enemy.swivelCannon(this.playerOne.pos);\n  }\n}\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 2\n// module chunks = 0","class Barrier {\n\n  constructor(xPos, yPos, width, height) {\n    this.xPos = xPos;\n    this.yPos = yPos;\n    this.width = width;\n    this.height = height;\n\n    this.sides = {\n      top: this.yPos,\n      right: (this.xPos + this.width),\n      bottom: (this.yPos + this.height),\n      left: this.xPos\n    };\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = 'red';\n    ctx.fillRect(this.xPos, this.yPos, this.width, this.height);\n  }\n\n}\n\nmodule.exports = Barrier;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/barrier.js\n// module id = 3\n// module chunks = 0","const Bullet = require('./bullet');\n\nclass Tank {\n  constructor(game) {\n    this.game = game;\n    this.moveDirection = [0, 0];\n    this.width = 50;\n  }\n\n  getSides() {\n    return {\n      top: this.pos[1] - (this.width / 2),\n      right: this.pos[0] + (this.width / 2),\n      bottom: this.pos[1] + (this.width / 2),\n      left: this.pos[0] - (this.width / 2)\n    };\n  }\n\n  draw(ctx) {\n    // tank body\n    ctx.fillStyle = this.color;\n    ctx.fillRect(\n      (this.pos[0] - (this.width / 2)),\n      (this.pos[1] - (this.width / 2)),\n      this.width,\n      this.width);\n\n    // tank center\n    ctx.fillStyle = 'white';\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], 5, 0, (2 * Math.PI), false);\n    ctx.fill();\n\n    // tank cannon\n    ctx.beginPath();\n    ctx.moveTo(this.pos[0], this.pos[1]);\n    ctx.lineTo(this.aimX, this.aimY);\n    ctx.strokeStyle = 'white';\n    ctx.lineWidth = 5;\n    ctx.stroke();\n  }\n\n  canMove(direction) {\n    let bool = true;\n\n    if ((direction[0] === 0) && (direction[1] === -1)) {\n      this.game.barriers.forEach(barrier => {\n        if ((this.sides.top === barrier.sides.bottom) && (\n          (this.sides.left >= barrier.sides.left &&\n          this.sides.left < barrier.sides.right) ||\n          (this.sides.right > barrier.sides.left &&\n          this.sides.right <= barrier.sides.right) ||\n          (this.pos[0] >= barrier.sides.left &&\n            this.pos[0] <= barrier.sides.right))) {\n              bool = false;\n            }\n      });\n    }\n\n    if ((direction[0] === 0) && (direction[1] === 1)) {\n      this.game.barriers.forEach(barrier => {\n        if ((this.sides.bottom === barrier.sides.top) && (\n          (this.sides.left >= barrier.sides.left &&\n          this.sides.left < barrier.sides.right) ||\n          (this.sides.right > barrier.sides.left &&\n          this.sides.right <= barrier.sides.right) ||\n          (this.pos[0] >= barrier.sides.left &&\n            this.pos[0] <= barrier.sides.right))) {\n              bool = false;\n            }\n      });\n    }\n\n    if ((direction[0] === -1) && (direction[1] === 0)) {\n      this.game.barriers.forEach(barrier => {\n        if ((this.sides.left === barrier.sides.right) && (\n          (this.sides.top > barrier.sides.top &&\n          this.sides.top < barrier.sides.bottom) ||\n          (this.sides.bottom > barrier.sides.top &&\n          this.sides.bottom < barrier.sides.bottom) ||\n          (this.pos[1] >= barrier.sides.top &&\n            this.pos[1] <= barrier.sides.bottom))) {\n              bool = false;\n            }\n      });\n    }\n\n    if ((direction[0] === 1) && (direction[1] === 0)) {\n      this.game.barriers.forEach(barrier => {\n        if ((this.sides.right === barrier.sides.left) && (\n          (this.sides.top > barrier.sides.top &&\n          this.sides.top < barrier.sides.bottom) ||\n          (this.sides.bottom > barrier.sides.top &&\n          this.sides.bottom < barrier.sides.bottom) ||\n          (this.pos[1] >= barrier.sides.top &&\n            this.pos[1] <= barrier.sides.bottom))) {\n              bool = false;\n            }\n      });\n    }\n\n    return bool;\n  }\n\n  move(direction) {\n    direction = [(direction[0] * 5), (direction[1] * 5)];\n    this.pos = [(this.pos[0] + direction[0]), (this.pos[1] + direction[1])];\n    this.sides = this.getSides();\n  }\n\n  swivelCannon(mousePos) {\n    let dX = this.pos[0] - mousePos[0];\n    let dY = mousePos[1] - this.pos[1];\n    let magic = Math.atan2(dX, dY) + (Math.PI / 2);\n\n    this.aimX = this.pos[0] + (35 * Math.cos(magic));\n    this.aimY = this.pos[1] + (35 * Math.sin(magic));\n  }\n\n  fire(mousePos) {\n    const bullet = new Bullet({ mousePos: mousePos, tankPos: this.pos });\n    this.game.addBullet(bullet);\n  }\n}\n\nmodule.exports = Tank;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tank.js\n// module id = 4\n// module chunks = 0","class GameView {\n\n  constructor(game, context, canvas) {\n    this.game = game;\n    this.context = context;\n    this.canvas = canvas;\n    this.mousePos = [400, 300];\n    this.tank = this.game.addTank();\n    this.enemy = this.game.addEnemies();\n\n    this.game.addBarriers();\n\n    this.setMousePosition = this.setMousePosition.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  listenForMouse() {\n    this.canvas.addEventListener('mousemove', this.setMousePosition);\n  }\n\n  setMousePosition(event) {\n    this.mousePos = [(event.clientX - 350), (event.clientY - 50)];\n    // this.tank.swivelCannon(this.mousePos);\n  }\n\n  listenForClick() {\n    this.canvas.addEventListener('click', this.handleClick);\n  }\n\n  handleClick() {\n    this.tank.fire(this.mousePos);\n  }\n\n  bindKeys() {\n    const tank = this.tank;\n\n    Object.keys(GameView.MOVES).forEach((k) => {\n      let direction = GameView.MOVES[k];\n      global.key(k, () => {\n        tank.moveDirection = direction;\n      });\n    });\n  }\n\n  start() {\n    this.bindKeys();\n\n    this.listenForMouse();\n    this.listenForClick();\n\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate() {\n    this.game.moveObjects(this.tank.moveDirection);\n    this.game.drawEverything(this.context, {mousePos: this.mousePos});\n\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n}\n\nGameView.MOVES = {\n  'w': [0, -1],\n  'a': [-1, 0],\n  's': [0, 1],\n  'd': [1, 0]\n};\n\nmodule.exports = GameView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game_view.js\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0","class Explosion {\n\n  constructor(pos) {\n    this.pos = pos;\n    this.radius = 0;\n    this.radiusTwo = 0;\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], this.radius, 0, (2 * Math.PI), false);\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.arc(this.pos[0], this.pos[1], this.radiusTwo, 0, (2 * Math.PI), false);\n    ctx.strokeStyle = 'orange';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n\n    this.radius = this.radius + 1;\n    this.radiusTwo = this.radiusTwo + .5;\n  }\n\n}\n\nmodule.exports = Explosion;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/explosion.js\n// module id = 7\n// module chunks = 0","const Tank = require('./tank');\n\nconst DEFAULTS = {\n  color: 'blue',\n  pos: [45, 300]\n};\n\nclass PlayerOne extends Tank {\n  constructor(game) {\n    super(game);\n\n    this.pos = DEFAULTS.pos;\n    this.color = DEFAULTS.color;\n    this.aimX = this.pos[0] + 35;\n    this.aimY = this.pos[1];\n    this.sides = this.getSides();\n  }\n\n}\n\nmodule.exports = PlayerOne;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/player_one.js\n// module id = 8\n// module chunks = 0","const Tank = require('./tank');\n\nconst DEFAULTS = {\n  color: 'red',\n  pos: [755, 300]\n};\n\nconst MOVES = {\n  up: [0, -1],\n  left: [-1, 0],\n  right: [0, 1],\n  down: [1, 0]\n};\n\nclass EnemyTank extends Tank {\n  constructor(game) {\n    super(game);\n\n    this.pos = DEFAULTS.pos;\n    this.color = DEFAULTS.color;\n    this.aimX = this.pos[0] - 35;\n    this.aimY = this.pos[1];\n\n    this.sides = this.getSides();\n\n    this.move(Object.keys(MOVES)[Math.floor(Math.random() * 4)]);\n  }\n\n  move() {\n    Object.keys(MOVES)[Math.floor(Math.random() * 4)]\n  }\n\n}\n\nmodule.exports = EnemyTank;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/enemy_tank.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}